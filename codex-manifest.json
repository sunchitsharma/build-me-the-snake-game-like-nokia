{"files": [{"path": "index.html", "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>shivani's 3d snake</title>\n  <style>\n    * { box-sizing: border-box; }\n    body {\n      margin: 0;\n      overflow: hidden;\n      font-family: 'Segoe UI', sans-serif;\n      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.04), transparent 30%),\n                  radial-gradient(circle at 80% 80%, rgba(255,255,255,0.03), transparent 25%),\n                  linear-gradient(135deg, #0a0a1a, #160022, #0a0a1a);\n      color: #e7f7ff;\n    }\n    .ui {\n      position: absolute;\n      top: 12px; left: 12px;\n      padding: 10px 14px;\n      background: rgba(0,0,0,0.45);\n      border: 1px solid rgba(255,255,255,0.08);\n      border-radius: 10px;\n      box-shadow: 0 10px 30px rgba(0,0,0,0.4);\n      backdrop-filter: blur(6px);\n    }\n    h1 {\n      margin: 0 0 6px;\n      font-size: 18px;\n      letter-spacing: 1px;\n    }\n    .stats { font-size: 14px; line-height: 1.5; }\n    .hint { font-size: 12px; opacity: 0.7; margin-top: 6px; }\n  </style>\n</head>\n<body>\n  <div class=\"ui\">\n    <h1>shivani's 3d snake</h1>\n    <div class=\"stats\">Score: <span id=\"score\">0</span><br/>Speed: <span id=\"speed\">6</span></div>\n    <div class=\"hint\">Use arrow keys / WASD to move</div>\n  </div>\n  <script src=\"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js\"></script>\n  <script>\n    // Basic config\n    const gridSize = 20;\n    const cellSize = 1;\n    const boardSize = gridSize * cellSize;\n    let speed = 6; // moves per second\n    let score = 0;\n    const scoreEl = document.getElementById('score');\n    const speedEl = document.getElementById('speed');\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x05060b);\n\n    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const cameraBasePos = new THREE.Vector3(gridSize * 0.5, 18, gridSize * 0.5 + 18);\n    camera.position.copy(cameraBasePos);\n    camera.lookAt(new THREE.Vector3(gridSize * 0.5, 0, gridSize * 0.5));\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.shadowMap.enabled = true;\n    document.body.appendChild(renderer.domElement);\n\n    // Lights\n    const ambient = new THREE.AmbientLight(0xffffff, 0.4);\n    scene.add(ambient);\n    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    dirLight.position.set(10, 25, 10);\n    dirLight.castShadow = true;\n    dirLight.shadow.mapSize.set(1024, 1024);\n    scene.add(dirLight);\n\n    // Cube board\n    const floorGeo = new THREE.BoxGeometry(boardSize, boardSize, boardSize);\n    const floorMat = new THREE.MeshStandardMaterial({ color: 0x0f2a1d, roughness: 0.8, metalness: 0.05 });\n    const floor = new THREE.Mesh(floorGeo, floorMat);\n    floor.position.y = -boardSize * 0.5;\n    floor.receiveShadow = true;\n    scene.add(floor);\n\n    const gridHelper = new THREE.GridHelper(gridSize, gridSize, 0x1a663f, 0x0f3c26);\n    gridHelper.position.y = 0.001;\n    scene.add(gridHelper);\n\n    // Snake materials\n    const snakeMat = new THREE.MeshStandardMaterial({ color: 0x5ce66e, metalness: 0.15, roughness: 0.35 });\n    const snakeHeadMat = new THREE.MeshStandardMaterial({ color: 0x7dff9f, emissive: 0x1f5c34, emissiveIntensity: 0.35, metalness: 0.25, roughness: 0.3 });\n    const foodMat = new THREE.MeshStandardMaterial({ color: 0xffc857, emissive: 0x995a00, emissiveIntensity: 0.5, metalness: 0.2, roughness: 0.35 });\n\n    // Snake state\n    let snake = [{ x: 10, y: 10 }];\n    let direction = { x: 1, y: 0 };\n    let nextDirection = { x: 1, y: 0 };\n    let food = spawnFood();\n\n    const snakeMeshes = [];\n    const foodMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 24, 24), foodMat);\n    foodMesh.castShadow = true;\n    scene.add(foodMesh);\n\n    function spawnFood() {\n      let pos;\n      do {\n        pos = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };\n      } while (snake.some(s => s.x === pos.x && s.y === pos.y));\n      return pos;\n    }\n\n    function resetGame() {\n      alert(`Game over! Score: ${score}`);\n      snake = [{ x: 10, y: 10 }];\n      direction = { x: 1, y: 0 };\n      nextDirection = { x: 1, y: 0 };\n      food = spawnFood();\n      score = 0;\n      speed = 6;\n      scoreEl.textContent = score;\n      speedEl.textContent = speed;\n    }\n\n    function updateSnakeGeometry() {\n      // Clear old meshes\n      snakeMeshes.forEach(m => scene.remove(m));\n      snakeMeshes.length = 0;\n\n      snake.forEach((segment, idx) => {\n        const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);\n        const mat = idx === 0 ? snakeHeadMat : snakeMat;\n        const mesh = new THREE.Mesh(geo, mat);\n        mesh.castShadow = true;\n        mesh.position.set(segment.x * cellSize - gridSize * 0.5 + cellSize * 0.5, 0.4, segment.y * cellSize - gridSize * 0.5 + cellSize * 0.5);\n        mesh.rotation.y = Math.sin((idx + performance.now() * 0.002)) * 0.05;\n        snakeMeshes.push(mesh);\n        scene.add(mesh);\n      });\n    }\n\n    function updateFoodGeometry() {\n      foodMesh.position.set(food.x * cellSize - gridSize * 0.5 + cellSize * 0.5, 0.35, food.y * cellSize - gridSize * 0.5 + cellSize * 0.5);\n    }\n\n    function tickMove() {\n      direction = nextDirection;\n      const head = {\n        x: (snake[0].x + direction.x + gridSize) % gridSize,\n        y: (snake[0].y + direction.y + gridSize) % gridSize\n      };\n      // self collision\n      if (snake.some(s => s.x === head.x && s.y === head.y)) {\n        resetGame();\n        return;\n      }\n      snake.unshift(head);\n      if (head.x === food.x && head.y === food.y) {\n        score += 10;\n        speed = Math.min(15, 6 + Math.floor(score / 50));\n        scoreEl.textContent = score;\n        speedEl.textContent = speed;\n        food = spawnFood();\n      } else {\n        snake.pop();\n      }\n      updateSnakeGeometry();\n      updateFoodGeometry();\n    }\n\n    // Timing control\n    let lastTime = 0;\n    let accumulator = 0;\n    function animate(time) {\n      if (!lastTime) lastTime = time;\n      const delta = time - lastTime;\n      lastTime = time;\n      accumulator += delta;\n      const interval = 1000 / speed;\n      while (accumulator >= interval) {\n        tickMove();\n        accumulator -= interval;\n      }\n\n      // subtle camera sway with clamp to keep board fully visible\n      const t = time * 0.0003;\n      const swayRadius = 5; // keep small to prevent grid from leaving view\n      camera.position.x = cameraBasePos.x + Math.cos(t) * swayRadius;\n      camera.position.z = cameraBasePos.z + Math.sin(t) * swayRadius;\n      camera.lookAt(new THREE.Vector3(gridSize * 0.5, 0, gridSize * 0.5));\n\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    }\n\n    // Controls\n    const keyMap = {\n      ArrowUp: { x: 0, y: -1 },\n      ArrowDown: { x: 0, y: 1 },\n      ArrowLeft: { x: -1, y: 0 },\n      ArrowRight: { x: 1, y: 0 },\n      w: { x: 0, y: -1 },\n      s: { x: 0, y: 1 },\n      a: { x: -1, y: 0 },\n      d: { x: 1, y: 0 }\n    };\n\n    document.addEventListener('keydown', (e) => {\n      const dir = keyMap[e.key];\n      if (!dir) return;\n      // prevent reversing directly\n      if (dir.x === -direction.x && dir.y === -direction.y) return;\n      nextDirection = dir;\n    });\n\n    window.addEventListener('resize', () => {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n\n    // Init\n    updateSnakeGeometry();\n    updateFoodGeometry();\n    requestAnimationFrame(animate);\n  </script>\n</body>\n</html>\n"}]}